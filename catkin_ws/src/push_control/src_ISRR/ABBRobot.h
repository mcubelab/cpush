#ifndef ABBROBOT_H
#define ABBROBOT_H

#include "geometry_msgs/WrenchStamped.h"
#include "PracticalSocket/PracticalSocket.h" // For UDPSocket and SocketException
#include "egm.pb.h" // generated by Google protoc.exe
#include "tf2_msgs/TFMessage.h"
#include "tf/LinearMath/Transform.h"

#include <ros/ros.h>
#include "tf/tf.h"
#include <tf/transform_datatypes.h>
#include <tf/transform_listener.h>
#include "geometry_msgs/Twist.h"
#include "geometry_msgs/WrenchStamped.h"
#include "std_msgs/String.h"

extern struct thread_data thread_data_array[1];
extern std::vector<geometry_msgs::WrenchStamped> ft_wrenches;
extern pthread_mutex_t nonBlockMutex;
extern double TimeGlobal;

using namespace abb::egm;
using namespace tf;
using namespace std;
using Eigen::MatrixXd;

// void *rriMain(void *thread_arg);
void chatterCallback(const geometry_msgs::WrenchStamped& msg_force);
void CreateSensorMessage(EgmSensor* pSensorMessage, float x, float y);
void CreateSensorMessageEmpty(EgmSensor* pSensorMessage);
void DisplayRobotMessage(EgmRobot *pRobotMessage, double& x, double& y, double& z);
bool getRobotPose(UDPSocket* EGMsock, string& sourceAddress, unsigned short& sourcePort, EgmRobot* pRobotMessage, double& robot_x, double& robot_y, double& robot_z);
bool getViconPose(MatrixXd& q_slider, TransformListener& listener);
bool getViconVel(MatrixXd& dq_slider, TransformListener& listener);
#endif  
